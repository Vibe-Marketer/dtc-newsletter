---
phase: 08-manual-execution
plan: 03
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - execution/batch_runner.py
  - output/products/
autonomous: false

must_haves:
  truths:
    - "8 products generated, each in output/products/"
    - "4-5 products are HTML tools or automations (hard stuff)"
    - "Each product has manifest.json with valid structure"
    - "Each product passes generator validation"
    - "No duplicate pain points (all 8 address distinct problems)"
  artifacts:
    - path: "output/products/*/manifest.json"
      provides: "Product manifest files"
      count: 8
    - path: "output/products/*/SALES_COPY.md"
      provides: "Sales copy for each product"
      count: 8
  key_links:
    - from: "execution/batch_runner.py"
      to: "execution/product_factory.py"
      via: "product generation wrapper"
      pattern: "from execution.product_factory import ProductFactory"
---

<objective>
Generate 8 products from Reddit pain points using the batch runner.

Purpose: Validate the product factory works end-to-end by generating 8 high-value digital products. Prioritize HTML tools and automations (hard stuff first) per CONTEXT.md decisions.

Output: 8 product packages in `output/products/`, each with manifest.json, deliverables, and sales copy.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-manual-execution/08-CONTEXT.md
@.planning/phases/08-manual-execution/08-RESEARCH.md
@.planning/phases/08-manual-execution/08-01-SUMMARY.md

# Core modules
@execution/batch_runner.py
@execution/product_factory.py
@execution/pain_point_miner.py
@execution/product_packager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add product generation to BatchRunner</name>
  <files>execution/batch_runner.py</files>
  <action>
Add product generation methods to BatchRunner:

```python
from execution.product_factory import ProductFactory
from pathlib import Path

# Product type distribution per CONTEXT.md
PRODUCT_TYPE_DISTRIBUTION = [
    "html_tool",    # Week 1
    "automation",   # Week 2
    "html_tool",    # Week 3
    "automation",   # Week 4
    "html_tool",    # Week 5 (5th hard product)
    "gpt_config",   # Week 6
    "sheets",       # Week 7
    "prompt_pack",  # Week 8
]

# Fallback types if primary fails
PRODUCT_TYPE_FALLBACKS = {
    "html_tool": ["automation", "sheets"],
    "automation": ["html_tool", "prompt_pack"],
    "gpt_config": ["prompt_pack", "sheets"],
    "sheets": ["pdf", "prompt_pack"],
    "prompt_pack": ["gpt_config", "pdf"],
    "pdf": ["prompt_pack", "sheets"],
}

class BatchRunner:
    # ... existing code ...
    
    def discover_pain_points(self, limit: int = 8) -> list[dict]:
        """
        Discover pain points using ProductFactory.
        
        Returns list of pain points with:
        - problem: The pain point description
        - category: E-com category (shipping, pricing, etc.)
        - source: Reddit post URL or ID
        - engagement: Upvotes + comments
        """
        if self.dry_run:
            return [
                {"problem": f"Mock pain point {i}", "category": "shipping", "engagement": 100}
                for i in range(1, limit + 1)
            ]
        
        factory = ProductFactory()
        return factory.discover_pain_points(limit=limit)
    
    def generate_products(self, pain_points: list[dict]) -> list[dict]:
        """
        Generate 8 products from pain points.
        
        For each pain point:
        1. Determine product type from distribution
        2. Generate via ProductFactory
        3. Validate output
        4. If fails: retry with fallback type
        5. Track cost and check budget
        """
        results = []
        factory = ProductFactory()
        
        for i, pain_point in enumerate(pain_points):
            product_type = PRODUCT_TYPE_DISTRIBUTION[i] if i < len(PRODUCT_TYPE_DISTRIBUTION) else "prompt_pack"
            problem = pain_point.get("problem", "Unknown problem")
            
            print(f"\n[{i+1}/{len(pain_points)}] Generating {product_type}: {problem[:40]}...")
            
            if not self.can_continue():
                print(f"  STOP: Budget exceeded (${self.tracker.get_total():.2f})")
                break
            
            if self.dry_run:
                results.append({
                    "week": i + 1,
                    "pain_point": problem,
                    "type": product_type,
                    "path": f"output/products/mock-{i+1}/",
                    "status": "dry_run",
                    "cost": 0,
                })
                continue
            
            # Try primary type
            success, result = self._try_generate_product(factory, pain_point, product_type)
            
            # If failed, try fallbacks
            if not success:
                fallbacks = PRODUCT_TYPE_FALLBACKS.get(product_type, [])
                for fallback_type in fallbacks:
                    print(f"  Retrying with {fallback_type}...")
                    success, result = self._try_generate_product(factory, pain_point, fallback_type)
                    if success:
                        product_type = fallback_type
                        break
            
            result["week"] = i + 1
            result["type"] = product_type
            results.append(result)
            
            if result.get("cost", 0) > 0:
                self.tracker.add_cost("product", result["cost"])
        
        self.results["products"] = results
        return results
    
    def _try_generate_product(self, factory: ProductFactory, pain_point: dict, product_type: str) -> tuple[bool, dict]:
        """Attempt to generate a product, return (success, result_dict)."""
        try:
            problem = pain_point.get("problem", "Unknown")
            product = factory.create_product(
                problem=problem,
                product_type=product_type,
            )
            
            # Check if product was generated successfully
            if product and product.output_path and product.output_path.exists():
                manifest_path = product.output_path / "manifest.json"
                if manifest_path.exists():
                    return True, {
                        "pain_point": problem,
                        "path": str(product.output_path),
                        "status": "success",
                        "cost": product.cost if hasattr(product, "cost") else 0,
                    }
            
            return False, {
                "pain_point": problem,
                "status": "failed",
                "error": "No output generated",
                "cost": 0,
            }
            
        except Exception as e:
            return False, {
                "pain_point": pain_point.get("problem", "Unknown"),
                "status": "error",
                "error": str(e),
                "cost": 0,
            }
```

Add CLI command:
```python
parser.add_argument("--generate-products", action="store_true")
parser.add_argument("--discover-pain-points", action="store_true")
```
  </action>
  <verify>
```bash
python -c "from execution.batch_runner import BatchRunner, PRODUCT_TYPE_DISTRIBUTION; print(f'Distribution: {PRODUCT_TYPE_DISTRIBUTION}')"
```
  </verify>
  <done>BatchRunner.generate_products() method exists with fallback type rotation.</done>
</task>

<task type="auto">
  <name>Task 2: Run product generation batch</name>
  <files>output/products/</files>
  <action>
Execute the product generation:

1. **Discover pain points**:
```bash
python execution/batch_runner.py --discover-pain-points
```
Should find 8+ pain points from Reddit (or use cached data if Reddit unavailable).

2. **Generate products**:
```bash
python execution/batch_runner.py --generate-products
```

**Expected flow:**
- Uses 8 pain points from discovery
- Generates each product with type from distribution
- Validates each output (manifest exists, deliverables present)
- Retries with fallback type if primary fails
- Tracks costs

3. **Monitor output**:
- Watch for "Generating html_tool X/8" progress
- Check `output/products/` for new directories
- Note any generation failures and fallback usage

4. **Handle failures**:
- If primary type fails: automatic retry with fallback
- If fallback also fails: log and continue (don't block batch)
- Note failures for human review
  </action>
  <verify>
```bash
ls -d output/products/*/
ls output/products/*/manifest.json | wc -l
```
  </verify>
  <done>8 product directories exist in output/products/. Each has manifest.json.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>8 digital products generated from Reddit pain points</what-built>
  <how-to-verify>
1. Check the count:
   ```bash
   ls -d output/products/*/ | wc -l
   ```
   Should show 8 directories.

2. Verify product type distribution:
   ```bash
   for d in output/products/*/; do cat "$d/manifest.json" | python -c "import json,sys; print(json.load(sys.stdin).get('product_type', 'unknown'))"; done
   ```
   Should show 4-5 html_tool/automation and 3-4 other types.

3. Functional test 2-3 products:
   - For HTML tool: Open in browser, verify it works
   - For automation: Check Python syntax (`python -m py_compile file.py`)
   - For GPT config: Check INSTRUCTIONS.md is substantial
   - For sheets: Check JSON definition or MANUAL_SETUP.md exists

4. Check sales copy exists:
   ```bash
   ls output/products/*/SALES_COPY.md | wc -l
   ```
   Should show 8 files.

5. Note any products needing regeneration.
  </how-to-verify>
  <resume-signal>Type "approved" if products look good, or describe which ones need regeneration</resume-signal>
</task>

</tasks>

<verification>
1. `ls -d output/products/*/ | wc -l` shows 8
2. Each directory has manifest.json
3. 4-5 products are html_tool or automation types
4. Human verified 2-3 products work functionally
</verification>

<success_criteria>
- 8 product packages exist in output/products/
- Each product has manifest.json with valid structure
- 4-5 products are HTML tools or automations (hard stuff)
- Each product has SALES_COPY.md
- Total cost tracked and under $40 budget
- Human has approved the batch quality
</success_criteria>

<output>
After completion, create `.planning/phases/08-manual-execution/08-03-SUMMARY.md`
</output>
