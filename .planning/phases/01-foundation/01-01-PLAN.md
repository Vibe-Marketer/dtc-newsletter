---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - .env.example
  - execution/__init__.py
  - execution/scoring.py
  - tests/test_scoring.py
autonomous: true

must_haves:
  truths:
    - "Outlier score formula produces expected results for known inputs"
    - "Recency boost correctly weights newer posts higher"
    - "Engagement modifiers apply correctly (+30% money, +20% time, +20% secrets, +15% controversy)"
    - "Dependencies are documented and installable"
  artifacts:
    - path: "requirements.txt"
      provides: "Project dependencies"
      contains: "praw"
    - path: ".env.example"
      provides: "Environment variable template"
      contains: "REDDIT_CLIENT_ID"
    - path: "execution/scoring.py"
      provides: "Outlier score calculation"
      exports: ["calculate_outlier_score", "apply_engagement_modifiers", "calculate_recency_boost"]
    - path: "tests/test_scoring.py"
      provides: "Scoring algorithm tests"
      min_lines: 50
  key_links:
    - from: "execution/scoring.py"
      to: "tests/test_scoring.py"
      via: "import and test"
      pattern: "from execution.scoring import"
---

<objective>
Set up project foundation and implement the outlier scoring algorithm.

Purpose: Create testable scoring logic that mirrors TubeLab's approach (upvotes / avg * recency * modifiers) before integrating with Reddit API.

Output:
- requirements.txt with PRAW and test dependencies
- .env.example template for Reddit API credentials
- execution/scoring.py with outlier calculation functions
- tests/test_scoring.py proving the algorithm works
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project Setup</name>
  <files>requirements.txt, .env.example, execution/__init__.py</files>
  <action>
Create requirements.txt with:
```
# Core
python-dotenv>=1.0.0
requests>=2.31.0

# Reddit
praw>=7.7.0

# Testing
pytest>=7.4.0
```

Create .env.example with:
```
# Reddit API (https://www.reddit.com/prefs/apps)
REDDIT_CLIENT_ID=your_client_id
REDDIT_CLIENT_SECRET=your_client_secret
REDDIT_USER_AGENT=dtc-newsletter-bot/1.0 by /u/yourusername
```

Create execution/__init__.py (empty, for Python package).

Create tests/__init__.py (empty, for Python package).
  </action>
  <verify>
```bash
pip install -r requirements.txt
python -c "import praw; import pytest; print('Dependencies OK')"
```
  </verify>
  <done>All dependencies install successfully, .env.example documents required credentials</done>
</task>

<task type="auto">
  <name>Task 2: Outlier Scoring Algorithm</name>
  <files>execution/scoring.py, tests/test_scoring.py</files>
  <action>
Create execution/scoring.py implementing:

```python
"""
Outlier scoring for Reddit content.

Formula: Outlier Score = (Post Upvotes / Subreddit Average) * Recency Boost * Engagement Modifiers

A score of 6.81 means that post performed almost 7x better than the subreddit's average.
"""

from datetime import datetime, timezone
from typing import Optional

def calculate_recency_boost(post_timestamp: float, max_boost: float = 1.3, decay_days: int = 7) -> float:
    """
    Calculate recency boost for a post.
    
    - Posts from today get max boost (1.3x)
    - Boost decays linearly over decay_days
    - Posts older than decay_days get 1.0x (no boost)
    
    Args:
        post_timestamp: Unix timestamp of post creation
        max_boost: Maximum boost for newest posts (default 1.3)
        decay_days: Days until boost reaches 1.0 (default 7)
    
    Returns:
        Float multiplier between 1.0 and max_boost
    """
    # Implementation: linear decay from max_boost to 1.0 over decay_days

def calculate_engagement_modifiers(title: str, selftext: str = "") -> float:
    """
    Apply engagement modifiers based on hook content.
    
    Modifiers (multiplicative):
    - +30% if hook involves money ($, revenue, profit, sales, income)
    - +20% if hook involves time (minutes, hours, fast, quick, instantly)
    - +20% if hook involves secrets (secret, hidden, nobody knows, little-known)
    - +15% if hook involves controversy (unpopular opinion, controversial, nobody talks about)
    
    Args:
        title: Post title
        selftext: Post body text (optional)
    
    Returns:
        Float multiplier >= 1.0
    """
    # Implementation: check for keywords, stack modifiers additively then convert to multiplier

def calculate_outlier_score(
    upvotes: int,
    subreddit_avg_upvotes: float,
    post_timestamp: float,
    title: str,
    selftext: str = ""
) -> float:
    """
    Calculate complete outlier score.
    
    Formula: (upvotes / subreddit_avg) * recency_boost * engagement_modifiers
    
    Args:
        upvotes: Post upvote count
        subreddit_avg_upvotes: Average upvotes for this subreddit
        post_timestamp: Unix timestamp of post creation
        title: Post title
        selftext: Post body text
    
    Returns:
        Outlier score (e.g., 6.81 = 7x better than average)
    """
    # Implementation: combine all three factors
```

Create tests/test_scoring.py with comprehensive tests:

```python
"""Tests for outlier scoring algorithm."""
import pytest
from datetime import datetime, timezone
from execution.scoring import (
    calculate_recency_boost,
    calculate_engagement_modifiers,
    calculate_outlier_score
)

class TestRecencyBoost:
    def test_brand_new_post_gets_max_boost(self):
        """Post from right now should get 1.3x boost."""
        now = datetime.now(timezone.utc).timestamp()
        assert calculate_recency_boost(now) == pytest.approx(1.3, rel=0.01)
    
    def test_week_old_post_gets_no_boost(self):
        """Post from 7 days ago should get 1.0x boost."""
        week_ago = datetime.now(timezone.utc).timestamp() - (7 * 24 * 60 * 60)
        assert calculate_recency_boost(week_ago) == pytest.approx(1.0, rel=0.01)
    
    def test_three_day_old_post_gets_partial_boost(self):
        """Post from 3.5 days ago should get ~1.15x boost."""
        half_week = datetime.now(timezone.utc).timestamp() - (3.5 * 24 * 60 * 60)
        assert calculate_recency_boost(half_week) == pytest.approx(1.15, rel=0.05)
    
    def test_old_post_never_below_one(self):
        """Posts older than decay_days should get exactly 1.0."""
        month_ago = datetime.now(timezone.utc).timestamp() - (30 * 24 * 60 * 60)
        assert calculate_recency_boost(month_ago) == 1.0


class TestEngagementModifiers:
    def test_money_keywords_add_30_percent(self):
        """Titles mentioning money should get +30%."""
        assert calculate_engagement_modifiers("How I made $50k in revenue") >= 1.3
        assert calculate_engagement_modifiers("Profit margins explained") >= 1.3
    
    def test_time_keywords_add_20_percent(self):
        """Titles mentioning time savings should get +20%."""
        assert calculate_engagement_modifiers("Set this up in 5 minutes") >= 1.2
        assert calculate_engagement_modifiers("Get results fast") >= 1.2
    
    def test_secrets_keywords_add_20_percent(self):
        """Titles with secret/hidden angle should get +20%."""
        assert calculate_engagement_modifiers("The secret to scaling") >= 1.2
        assert calculate_engagement_modifiers("Hidden feature nobody uses") >= 1.2
    
    def test_controversy_keywords_add_15_percent(self):
        """Controversial hooks should get +15%."""
        assert calculate_engagement_modifiers("Unpopular opinion: dropshipping is dead") >= 1.15
    
    def test_multiple_modifiers_stack(self):
        """Multiple hooks should stack."""
        # Money + Time = 1.0 + 0.3 + 0.2 = 1.5
        score = calculate_engagement_modifiers("Made $10k in 30 minutes")
        assert score >= 1.5
    
    def test_no_keywords_returns_one(self):
        """Neutral title should get 1.0."""
        assert calculate_engagement_modifiers("Just a regular post") == 1.0


class TestOutlierScore:
    def test_basic_calculation(self):
        """Test the core formula without modifiers."""
        # 1000 upvotes / 200 avg = 5.0 base
        # With 1.0 recency and 1.0 modifiers = 5.0
        week_ago = datetime.now(timezone.utc).timestamp() - (7 * 24 * 60 * 60)
        score = calculate_outlier_score(
            upvotes=1000,
            subreddit_avg_upvotes=200,
            post_timestamp=week_ago,
            title="Regular post"
        )
        assert score == pytest.approx(5.0, rel=0.1)
    
    def test_with_recency_boost(self):
        """New post should score higher."""
        now = datetime.now(timezone.utc).timestamp()
        score = calculate_outlier_score(
            upvotes=1000,
            subreddit_avg_upvotes=200,
            post_timestamp=now,
            title="Regular post"
        )
        # 5.0 * 1.3 = 6.5
        assert score == pytest.approx(6.5, rel=0.1)
    
    def test_with_engagement_modifiers(self):
        """Money hook should boost score."""
        week_ago = datetime.now(timezone.utc).timestamp() - (7 * 24 * 60 * 60)
        score = calculate_outlier_score(
            upvotes=1000,
            subreddit_avg_upvotes=200,
            post_timestamp=week_ago,
            title="How I made $50k revenue"
        )
        # 5.0 * 1.0 * 1.3 = 6.5
        assert score >= 6.5
    
    def test_full_calculation(self):
        """Test with all multipliers."""
        now = datetime.now(timezone.utc).timestamp()
        score = calculate_outlier_score(
            upvotes=1000,
            subreddit_avg_upvotes=200,
            post_timestamp=now,
            title="Secret to making $10k fast"
        )
        # 5.0 * 1.3 * (1 + 0.3 + 0.2 + 0.2) = 5 * 1.3 * 1.7 = 11.05
        assert score >= 10.0
    
    def test_below_average_post(self):
        """Post below average should score < 1.0."""
        week_ago = datetime.now(timezone.utc).timestamp() - (7 * 24 * 60 * 60)
        score = calculate_outlier_score(
            upvotes=50,
            subreddit_avg_upvotes=200,
            post_timestamp=week_ago,
            title="Regular post"
        )
        assert score == pytest.approx(0.25, rel=0.1)
```

Implement the functions in scoring.py to pass all tests.
  </action>
  <verify>
```bash
cd /Users/Naegele/dev/dtc-newsletter && python -m pytest tests/test_scoring.py -v
```
All tests should pass.
  </verify>
  <done>
- calculate_recency_boost returns 1.3 for new posts, 1.0 for week-old posts
- calculate_engagement_modifiers correctly detects money (+30%), time (+20%), secrets (+20%), controversy (+15%)
- calculate_outlier_score combines all factors correctly
- All pytest tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# All dependencies installed
pip list | grep -E "praw|pytest|python-dotenv"

# All tests pass
python -m pytest tests/test_scoring.py -v

# Module can be imported
python -c "from execution.scoring import calculate_outlier_score; print('Scoring module OK')"
```
</verification>

<success_criteria>
1. requirements.txt exists with praw>=7.7.0, pytest>=7.4.0, python-dotenv>=1.0.0
2. .env.example documents REDDIT_CLIENT_ID, REDDIT_CLIENT_SECRET, REDDIT_USER_AGENT
3. execution/scoring.py exports calculate_outlier_score, calculate_recency_boost, calculate_engagement_modifiers
4. tests/test_scoring.py has 10+ test cases covering edge cases
5. All tests pass with pytest
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
