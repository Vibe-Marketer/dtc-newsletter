---
phase: 06-product-factory
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - execution/generators/html_tool.py
  - execution/generators/automation.py
  - data/product_templates/html/base.html
  - tests/test_html_tool_generator.py
  - tests/test_automation_generator.py
autonomous: true

must_haves:
  truths:
    - "HTML tools generate as single-file standalone apps with embedded CSS/JS"
    - "HTML tools work offline in any browser"
    - "Automations generate as documented Python scripts"
    - "Automations include requirements.txt and README"
  artifacts:
    - path: "execution/generators/html_tool.py"
      provides: "Single-file HTML tool generator"
      exports: ["HtmlToolGenerator"]
    - path: "execution/generators/automation.py"
      provides: "Python automation script generator"
      exports: ["AutomationGenerator"]
  key_links:
    - from: "execution/generators/html_tool.py"
      to: "execution/generators/base_generator.py"
      via: "inherits BaseGenerator"
      pattern: "class HtmlToolGenerator\\(BaseGenerator\\)"
    - from: "execution/generators/automation.py"
      to: "execution/generators/base_generator.py"
      via: "inherits BaseGenerator"
      pattern: "class AutomationGenerator\\(BaseGenerator\\)"
---

<objective>
Create HTML tool and automation generators - the two highest-value product types that require the most engineering.

Purpose: Generate working single-file HTML apps (calculators, generators) and documented Python scripts.
Output: Two functional generators with templates and tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-product-factory/06-RESEARCH.md
@.planning/phases/06-product-factory/06-01-SUMMARY.md
@execution/generators/base_generator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTML tool generator</name>
  <files>execution/generators/html_tool.py, data/product_templates/html/base.html, tests/test_html_tool_generator.py</files>
  <action>
Create data/product_templates/html/base.html as Jinja2 template:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <style>
        {{ css }}
    </style>
</head>
<body>
    {{ body }}
    <script>
        {{ javascript }}
    </script>
</body>
</html>
```

Create execution/generators/html_tool.py:

1. Import Jinja2 Template, BaseGenerator, ProductSpec, GeneratedProduct

2. Define HTML_TOOL_PROMPT for Claude to generate tool content:
   - Takes problem, solution_name, key_benefits as context
   - Outputs structured JSON with: title, css, body_html, javascript
   - CSS should be modern, clean, responsive (mobile-first)
   - JS should be vanilla JavaScript (no frameworks)
   - Body should include inputs, buttons, output areas as needed

3. HtmlToolGenerator(BaseGenerator):
   - __init__(self, claude_client=None, template_path=None)
   - get_product_type() -> "html_tool"
   - generate(spec: ProductSpec) -> GeneratedProduct:
     - Uses Claude to generate tool structure based on spec.problem and spec.solution_name
     - Renders Jinja2 template with Claude's output
     - Returns GeneratedProduct with files: {"[name].html": html_bytes, "README.md": readme_bytes}
   - validate(product: GeneratedProduct) -> bool:
     - Checks HTML file exists
     - Checks HTML has DOCTYPE, html, head, body tags
     - Checks JavaScript doesn't have syntax errors (basic check)
   - _generate_readme(spec: ProductSpec, filename: str) -> str:
     - Creates README with: problem solved, how to use, file list

Create tests/test_html_tool_generator.py:
- Test generator inherits from BaseGenerator
- Test get_product_type returns "html_tool"
- Test generate produces files dict with .html file
- Test generate includes README.md
- Test validate catches missing DOCTYPE
- Test validate catches missing body tag
- Test HTML is valid structure (has html, head, body)
- Mock Claude client to return structured tool definition
  </action>
  <verify>pytest tests/test_html_tool_generator.py -v passes with 8+ tests</verify>
  <done>HTML tool generator creates single-file standalone apps with embedded CSS/JS</done>
</task>

<task type="auto">
  <name>Task 2: Create automation generator</name>
  <files>execution/generators/automation.py, tests/test_automation_generator.py</files>
  <action>
Create execution/generators/automation.py:

1. Import BaseGenerator, ProductSpec, GeneratedProduct

2. Define AUTOMATION_PROMPT for Claude to generate Python script:
   - Takes problem, solution_name, key_benefits as context
   - Outputs structured response with: script_code, requirements (list), usage_instructions
   - Script should be well-documented with docstrings
   - Script should have argparse CLI interface
   - Script should handle errors gracefully with try/except

3. AutomationGenerator(BaseGenerator):
   - __init__(self, claude_client=None)
   - get_product_type() -> "automation"
   - generate(spec: ProductSpec) -> GeneratedProduct:
     - Uses Claude to generate script based on spec.problem
     - Returns GeneratedProduct with files:
       - "[name].py": The main script
       - "requirements.txt": Dependencies list
       - "README.md": Usage instructions
   - validate(product: GeneratedProduct) -> bool:
     - Checks .py file exists
     - Checks requirements.txt exists
     - Checks script has docstring
     - Checks script has if __name__ == "__main__" block
     - Uses ast.parse() to verify Python syntax is valid
   - _generate_requirements_txt(requirements: list[str]) -> str
   - _generate_readme(spec: ProductSpec, script_name: str, usage: str) -> str

Create tests/test_automation_generator.py:
- Test generator inherits from BaseGenerator
- Test get_product_type returns "automation"
- Test generate produces .py, requirements.txt, README.md
- Test validate catches missing docstring
- Test validate catches syntax errors (use ast.parse mock)
- Test validate catches missing __main__ block
- Test requirements.txt format is correct
- Mock Claude client to return valid script structure
  </action>
  <verify>pytest tests/test_automation_generator.py -v passes with 8+ tests</verify>
  <done>Automation generator creates documented Python scripts with CLI interface</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_html_tool_generator.py tests/test_automation_generator.py -v` - All tests pass
2. `python -c "from execution.generators.html_tool import HtmlToolGenerator"` - Import works
3. `python -c "from execution.generators.automation import AutomationGenerator"` - Import works
</verification>

<success_criteria>
1. HTML tool generator creates single-file standalone HTML apps
2. Automation generator creates documented Python scripts with CLI
3. Both generators inherit from BaseGenerator
4. Both generators include README documentation
5. 16+ tests passing for these generators
</success_criteria>

<output>
After completion, create `.planning/phases/06-product-factory/06-02-SUMMARY.md`
</output>
