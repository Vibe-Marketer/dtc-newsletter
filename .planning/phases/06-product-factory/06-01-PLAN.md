---
phase: 06-product-factory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - execution/pain_point_miner.py
  - execution/generators/__init__.py
  - execution/generators/base_generator.py
  - tests/test_pain_point_miner.py
  - tests/test_base_generator.py
autonomous: true

must_haves:
  truths:
    - "Pain points can be searched on Reddit with complaint-focused keywords"
    - "Pain points are scored by engagement (high upvotes + comments = real pain)"
    - "All product generators inherit from a common base class"
    - "ProductSpec and GeneratedProduct dataclasses define the contract"
  artifacts:
    - path: "execution/pain_point_miner.py"
      provides: "Reddit pain point search with scoring"
      exports: ["search_pain_points", "PAIN_KEYWORDS", "PAIN_SUBREDDITS"]
    - path: "execution/generators/base_generator.py"
      provides: "Abstract base class for all generators"
      exports: ["BaseGenerator", "ProductSpec", "GeneratedProduct"]
  key_links:
    - from: "execution/pain_point_miner.py"
      to: "execution/reddit_fetcher.py"
      via: "imports get_reddit_client"
      pattern: "from execution.reddit_fetcher import"
---

<objective>
Create the foundation for the Product Factory: pain point mining from Reddit and the base generator class that all product generators will inherit from.

Purpose: Enable discovery of specific e-commerce problems worth solving and establish the contract for product generation.
Output: Working pain point miner and base generator class with tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-product-factory/06-RESEARCH.md
@execution/reddit_fetcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pain point miner</name>
  <files>execution/pain_point_miner.py, tests/test_pain_point_miner.py</files>
  <action>
Create execution/pain_point_miner.py that:

1. Imports get_reddit_client from reddit_fetcher.py (reuse existing PRAW setup)

2. Defines PAIN_KEYWORDS list targeting e-commerce complaints:
   - Frustration signals: "frustrated with shopify", "hate my shopify", "shopify problem"
   - Help-seeking: "struggling with ecommerce", "need help with store", "can't figure out"
   - Specific pains: "conversion rate low", "cart abandonment", "shipping nightmare", "inventory management hell", "returns killing me"

3. Defines PAIN_SUBREDDITS list:
   - shopify, ecommerce, dropship, Entrepreneur, smallbusiness, FulfillmentByAmazon

4. Implements search_pain_points(subreddits, keywords, limit=100, time_filter="month") -> list[dict]:
   - Uses reddit.subreddit(name).search(keyword, limit=limit, time_filter=time_filter)
   - Returns list of pain point dicts with: title, body (first 500 chars), score, comments, url, keyword, subreddit
   - Sorts by engagement score (upvotes + comments) descending
   - Deduplicates by post ID

5. Implements categorize_pain_point(pain_point: dict) -> str:
   - Returns category based on keywords: "shipping", "inventory", "conversion", "returns", "pricing", "marketing", "other"

6. Implements get_top_pain_points(limit=20) -> list[dict]:
   - Convenience function that searches all subreddits/keywords
   - Returns top N by engagement

Create tests/test_pain_point_miner.py with:
- Test PAIN_KEYWORDS contains expected complaint indicators
- Test PAIN_SUBREDDITS contains target subreddits
- Test search_pain_points with mocked Reddit (mock reddit.subreddit().search())
- Test categorize_pain_point correctly categorizes by keyword
- Test deduplication works (same post ID not duplicated)
- Test sorting by engagement score
  </action>
  <verify>pytest tests/test_pain_point_miner.py -v passes with 10+ tests</verify>
  <done>Pain point miner searches Reddit for complaints, scores by engagement, and categorizes results</done>
</task>

<task type="auto">
  <name>Task 2: Create base generator class</name>
  <files>execution/generators/__init__.py, execution/generators/base_generator.py, tests/test_base_generator.py</files>
  <action>
Create execution/generators/__init__.py:
- Export BaseGenerator, ProductSpec, GeneratedProduct from base_generator

Create execution/generators/base_generator.py with:

1. ProductSpec dataclass:
   - problem: str - The pain point being solved
   - solution_name: str - Product name
   - target_audience: str - Who it's for
   - key_benefits: list[str] - 3-5 benefits
   - product_type: str - One of: html_tool, automation, gpt_config, sheets, pdf, prompt_pack
   - Optional fields: price_cents: int = None, perceived_value: str = None

2. GeneratedProduct dataclass:
   - files: dict[str, bytes] - filename -> content mapping
   - manifest: dict - Product metadata (name, type, version, etc.)
   - sales_copy: Optional[str] = None - Generated sales copy

3. BaseGenerator abstract class:
   - __init__(self, claude_client=None) - Optional claude client injection
   - abstract generate(self, spec: ProductSpec) -> GeneratedProduct
   - abstract validate(self, product: GeneratedProduct) -> bool
   - get_product_type(self) -> str - Returns the product type this generator handles
   - _create_manifest(self, spec: ProductSpec, files: list[str]) -> dict - Helper to build manifest

4. Manifest structure should include:
   - id: auto-generated UUID
   - name: from spec.solution_name
   - type: from spec.product_type
   - version: "1.0.0"
   - created_at: ISO timestamp
   - problem: spec.problem
   - audience: spec.target_audience
   - benefits: spec.key_benefits
   - deliverables: list of file info dicts

Create tests/test_base_generator.py with:
- Test ProductSpec creation with all fields
- Test ProductSpec with optional fields defaulted
- Test GeneratedProduct creation
- Test BaseGenerator cannot be instantiated directly (abstract)
- Test _create_manifest produces valid structure
- Test manifest includes UUID, timestamp, deliverables list
  </action>
  <verify>pytest tests/test_base_generator.py -v passes with 8+ tests</verify>
  <done>Base generator class defines the contract for all product generators with ProductSpec input and GeneratedProduct output</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_pain_point_miner.py tests/test_base_generator.py -v` - All tests pass
2. `python -c "from execution.pain_point_miner import search_pain_points, PAIN_KEYWORDS"` - Imports work
3. `python -c "from execution.generators import BaseGenerator, ProductSpec, GeneratedProduct"` - Imports work
</verification>

<success_criteria>
1. Pain point miner can search Reddit for e-com complaints with engagement scoring
2. Base generator class defines ProductSpec -> GeneratedProduct contract
3. All generators will inherit from BaseGenerator
4. 18+ tests passing for foundation components
</success_criteria>

<output>
After completion, create `.planning/phases/06-product-factory/06-01-SUMMARY.md`
</output>
