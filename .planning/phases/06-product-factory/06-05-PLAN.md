---
phase: 06-product-factory
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03", "06-04"]
files_modified:
  - execution/sales_copy_generator.py
  - execution/pricing_recommender.py
  - execution/product_packager.py
  - tests/test_sales_copy_generator.py
  - tests/test_pricing_recommender.py
  - tests/test_product_packager.py
autonomous: true

must_haves:
  truths:
    - "Sales copy follows Hormozi/Suby voice from voice_profile.py"
    - "Sales copy includes headline, benefits, value anchor, CTA"
    - "Pricing is $27-97 based on product type and perceived value"
    - "Product packages are complete with all deliverables + sales copy + manifest"
  artifacts:
    - path: "execution/sales_copy_generator.py"
      provides: "AI sales copy generation with voice profile"
      exports: ["generate_sales_copy", "SalesCopyGenerator"]
    - path: "execution/pricing_recommender.py"
      provides: "Pricing recommendations based on value"
      exports: ["recommend_price", "PRICING_TIERS"]
    - path: "execution/product_packager.py"
      provides: "Complete product package assembly"
      exports: ["ProductPackager", "package_product"]
  key_links:
    - from: "execution/sales_copy_generator.py"
      to: "execution/voice_profile.py"
      via: "imports VOICE_PROFILE_PROMPT"
      pattern: "from execution.voice_profile import"
    - from: "execution/product_packager.py"
      to: "execution/generators/"
      via: "uses all generators"
      pattern: "from execution.generators import"
---

<objective>
Create sales copy generator, pricing recommender, and product packager - the final assembly layer that packages generated products for sale.

Purpose: Generate compelling sales copy, recommend optimal pricing, and assemble complete product packages.
Output: Three modules that complete the product creation pipeline.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-product-factory/06-RESEARCH.md
@.planning/phases/06-product-factory/06-01-SUMMARY.md
@execution/voice_profile.py
@execution/claude_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sales copy generator</name>
  <files>execution/sales_copy_generator.py, tests/test_sales_copy_generator.py</files>
  <action>
Create execution/sales_copy_generator.py:

1. Import from voice_profile.py, claude_client.py
2. Import ProductSpec from generators.base_generator

3. Define SALES_COPY_PROMPT template:
   ```
   Generate sales copy for this digital product:
   
   PRODUCT: {product_name}
   PROBLEM IT SOLVES: {problem}
   TARGET AUDIENCE: {audience}
   KEY BENEFITS: {benefits}
   
   Generate these sections:
   1. HEADLINE (curiosity + benefit, under 10 words)
   2. SUBHEADLINE (expands on promise, under 20 words)
   3. PROBLEM SECTION (2-3 sentences agitating the pain)
   4. SOLUTION SECTION (how this product solves it)
   5. BENEFIT BULLETS (5 specific outcomes with numbers when possible)
   6. VALUE ANCHOR (what this is worth / what alternatives cost)
   7. PRICE JUSTIFICATION (why this price is a steal)
   8. CTA (action-oriented call to action)
   
   Use the DTC Money Minute voice: short sentences, specific numbers, zero fluff.
   ```

4. SalesCopyGenerator class:
   - __init__(self, claude_client=None)
   - generate(spec: ProductSpec, price_display: str, perceived_value: str) -> dict:
     - Uses Claude with voice profile to generate each section
     - Returns dict with all 8 sections
   - format_markdown(copy_dict: dict) -> str:
     - Formats sales copy as clean markdown
   - validate(copy_dict: dict) -> tuple[bool, list[str]]:
     - Checks all 8 sections present
     - Checks headline under 10 words
     - Checks at least 5 benefit bullets
     - Returns (valid, list of issues)

5. Convenience function:
   - generate_sales_copy(spec: ProductSpec, price_display: str, perceived_value: str) -> str:
     - Creates generator, generates, formats, returns markdown

Create tests/test_sales_copy_generator.py:
- Test SalesCopyGenerator can be instantiated
- Test generate returns dict with all 8 sections
- Test format_markdown produces valid markdown
- Test validate catches missing sections
- Test validate catches headline > 10 words
- Test validate catches < 5 benefit bullets
- Test uses voice profile (mock claude client)
- Test convenience function works
  </action>
  <verify>pytest tests/test_sales_copy_generator.py -v passes with 8+ tests</verify>
  <done>Sales copy generator creates compelling copy following voice profile</done>
</task>

<task type="auto">
  <name>Task 2: Create pricing recommender</name>
  <files>execution/pricing_recommender.py, tests/test_pricing_recommender.py</files>
  <action>
Create execution/pricing_recommender.py:

1. Define PRICING_TIERS dict:
   ```python
   PRICING_TIERS = {
       "html_tool": {"base": 27, "premium": 47, "perceived_multiplier": 10},
       "automation": {"base": 47, "premium": 97, "perceived_multiplier": 15},
       "gpt_config": {"base": 27, "premium": 47, "perceived_multiplier": 8},
       "sheets": {"base": 27, "premium": 47, "perceived_multiplier": 10},
       "pdf": {"base": 17, "premium": 37, "perceived_multiplier": 5},
       "prompt_pack": {"base": 17, "premium": 27, "perceived_multiplier": 5},
   }
   ```

2. Define VALUE_SIGNALS list:
   - time_saved: "saves X hours/week"
   - money_impact: "generates/saves $X"
   - complexity: "replaces X-step process"
   - exclusivity: "insider/advanced technique"

3. PricingRecommender class:
   - __init__(self)
   - recommend(product_type: str, value_signals: dict) -> dict:
     - Calculates recommended price based on type and signals
     - Returns {price_cents, price_display, perceived_value, justification}
   - _calculate_perceived_value(product_type: str, value_signals: dict) -> str:
     - Generates perceived value statement (e.g., "$500+ worth of...")
   - _select_tier(product_type: str, signal_strength: float) -> str:
     - Returns "base" or "premium" based on signal strength

4. Convenience function:
   - recommend_price(product_type: str, value_signals: dict = None) -> dict

Create tests/test_pricing_recommender.py:
- Test PRICING_TIERS has all product types
- Test recommend returns required fields
- Test automation gets higher base price than pdf
- Test premium tier selected with strong signals
- Test base tier selected with weak signals
- Test perceived_value includes multiplier
- Test convenience function works
- Test unknown product type raises error
  </action>
  <verify>pytest tests/test_pricing_recommender.py -v passes with 8+ tests</verify>
  <done>Pricing recommender suggests $27-97 prices based on product type and value signals</done>
</task>

<task type="auto">
  <name>Task 3: Create product packager</name>
  <files>execution/product_packager.py, tests/test_product_packager.py</files>
  <action>
Create execution/product_packager.py:

1. Import all generators from execution.generators
2. Import SalesCopyGenerator, PricingRecommender
3. Import ProductSpec, GeneratedProduct from base_generator
4. Import json, os, zipfile, datetime

5. Define GENERATOR_MAP:
   ```python
   GENERATOR_MAP = {
       "html_tool": HtmlToolGenerator,
       "automation": AutomationGenerator,
       "gpt_config": GptConfigGenerator,
       "sheets": SheetsGenerator,
       "pdf": PdfGenerator,
       "prompt_pack": PromptPackGenerator,
   }
   ```

6. ProductPackager class:
   - __init__(self, claude_client=None, output_dir="output/products"):
     - Initializes all generators with shared claude_client
   - package(spec: ProductSpec) -> dict:
     - Selects correct generator based on spec.product_type
     - Generates product using generator
     - Generates sales copy
     - Recommends pricing
     - Creates manifest with all metadata
     - Saves to output_dir/[product_id]/
     - Returns {product_id, path, manifest, url (if applicable)}
   - _save_product(product_id: str, product: GeneratedProduct, sales_copy: str, manifest: dict) -> str:
     - Creates directory structure
     - Saves all files
     - Returns path
   - _create_zip(product_id: str, product_path: str) -> str:
     - Creates downloadable zip file
     - Returns zip path

7. Convenience function:
   - package_product(spec: ProductSpec, output_dir: str = None) -> dict

Create tests/test_product_packager.py:
- Test ProductPackager can be instantiated
- Test GENERATOR_MAP has all product types
- Test package selects correct generator
- Test package creates output directory
- Test manifest includes all required fields
- Test sales copy is included in package
- Test pricing is included in manifest
- Test zip file is created
- Mock generators and claude client
  </action>
  <verify>pytest tests/test_product_packager.py -v passes with 9+ tests</verify>
  <done>Product packager assembles complete packages with all deliverables, sales copy, and manifest</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_sales_copy_generator.py tests/test_pricing_recommender.py tests/test_product_packager.py -v` - All tests pass
2. `python -c "from execution.sales_copy_generator import generate_sales_copy"` - Import works
3. `python -c "from execution.pricing_recommender import recommend_price"` - Import works
4. `python -c "from execution.product_packager import ProductPackager"` - Import works
</verification>

<success_criteria>
1. Sales copy generator creates compelling copy following voice profile
2. Pricing recommender suggests $27-97 prices based on type and value
3. Product packager assembles complete packages ready to sell
4. All packages include deliverables + sales copy + pricing + manifest
5. 25+ tests passing for packaging layer
</success_criteria>

<output>
After completion, create `.planning/phases/06-product-factory/06-05-SUMMARY.md`
</output>
