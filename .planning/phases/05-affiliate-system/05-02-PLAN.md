---
phase: 05-affiliate-system
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - execution/product_alternatives.py
  - execution/monetization_output.py
  - directives/affiliate_finder.md
  - execution/affiliate_finder.py
  - tests/test_product_alternatives.py
  - tests/test_monetization_output.py
autonomous: true

must_haves:
  truths:
    - "Product alternatives generated for each newsletter topic"
    - "Combined output shows both affiliates and products side-by-side"
    - "Output includes ranking rationale for decision-making"
    - "Pitch angles ready to copy/paste into Section 4"
    - "DOE directive matches script version"
  artifacts:
    - path: "execution/product_alternatives.py"
      provides: "Product idea generation as affiliate alternative"
      exports: ["generate_product_alternatives", "ProductIdea"]
    - path: "execution/monetization_output.py"
      provides: "Combined output formatter"
      exports: ["format_monetization_output", "MonetizationOption"]
    - path: "execution/affiliate_finder.py"
      provides: "CLI orchestrator for monetization discovery"
      exports: ["main", "run_monetization_discovery"]
    - path: "directives/affiliate_finder.md"
      provides: "DOE directive for affiliate discovery"
      contains: "DOE-VERSION: 2026.01.31"
  key_links:
    - from: "execution/monetization_output.py"
      to: "execution/affiliate_discovery.py"
      via: "Imports AffiliateProgram model"
      pattern: "from execution.affiliate_discovery import"
    - from: "execution/affiliate_finder.py"
      to: "execution/monetization_output.py"
      via: "Orchestrates full discovery flow"
      pattern: "from execution.monetization_output import"
    - from: "directives/affiliate_finder.md"
      to: "execution/affiliate_finder.py"
      via: "DOE version match"
      pattern: "DOE-VERSION: 2026.01.31"
---

<objective>
Build product alternatives generator, output formatter, and DOE crystallization.

Purpose: Complete the monetization discovery system with dual-track output (affiliates + products) and crystallize as DOE workflow.

Output: product_alternatives.py (product idea generation), monetization_output.py (combined formatter), affiliate_finder.py (CLI orchestrator), and directive/affiliate_finder.md (DOE workflow).
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-affiliate-system/05-CONTEXT.md
@.planning/phases/05-affiliate-system/05-RESEARCH.md
@.planning/phases/05-affiliate-system/05-01-SUMMARY.md
@execution/affiliate_discovery.py
@execution/pitch_generator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product alternatives module</name>
  <files>execution/product_alternatives.py, tests/test_product_alternatives.py</files>
  <action>
Create product_alternatives.py with:

1. **Pydantic models:**
   - `ProductIdea`: concept (str, 1 sentence), product_type (HTML tool|automation|GPT|Google Sheet|PDF|prompt pack), estimated_value (str like "$47-97"), build_complexity (easy|medium|hard), why_beats_affiliate (str, 1 sentence), pitch_angle (str, 2-3 sentences)

   - `ProductAlternativesResult`: products list, topic, generated_at

2. **generate_product_alternatives(topic: str, newsletter_context: str = "") -> ProductAlternativesResult:**
   - Use Perplexity for research + Claude for refinement (two-stage per RESEARCH.md)
   - Stage 1 (Perplexity): Research pain points around topic for DTC audience
   - Stage 2 (Claude): Generate 3 product ideas that solve specific pain points
   
   Product constraints (from PROJECT.md):
   - Target $27-97 price range
   - Must solve specific, narrow problem
   - Prefer HTML tools and automations (per "hard first" decision)
   
   Each product must include:
   - Concrete concept
   - Product type
   - Estimated perceived value
   - Build complexity
   - Why it might beat affiliate option
   - Ready-to-use pitch angle (matching voice profile)

3. **rank_products(products: list[ProductIdea]) -> list[ProductIdea]:**
   - Rank by: value/complexity ratio (higher value + lower complexity = better)
   - Return sorted list

Tests (test_product_alternatives.py):
- Test product generation with mocked API responses
- Test ranking logic with various value/complexity combinations
- Test all product types generate correctly
- Test pitch angles match voice requirements
  </action>
  <verify>pytest tests/test_product_alternatives.py -v passes all tests</verify>
  <done>generate_product_alternatives() returns 3 ranked ProductIdea objects with pitch angles; ranking prioritizes high value + low complexity</done>
</task>

<task type="auto">
  <name>Task 2: Create monetization output formatter</name>
  <files>execution/monetization_output.py, tests/test_monetization_output.py</files>
  <action>
Create monetization_output.py with:

1. **Unified model:**
   ```python
   @dataclass
   class MonetizationOption:
       type: Literal["affiliate", "product"]
       name: str
       description: str
       pitch_angle: str
       
       # For affiliates
       commission_rate: str | None = None
       commission_quality: str | None = None  # excellent/good/mediocre/poor
       network: str | None = None
       
       # For products
       product_type: str | None = None
       build_complexity: str | None = None
       estimated_value: str | None = None
   ```

2. **format_monetization_output(affiliates: list[AffiliateProgram], products: list[ProductIdea], topic: str, pitches: dict[str, str]) -> str:**
   
   Output format (per CONTEXT.md):
   ```markdown
   # Monetization Options: {topic}
   
   ## Top 3 Affiliate Opportunities
   
   | # | Program | Commission | Quality | Network |
   |---|---------|------------|---------|---------|
   | 1 | {name} | {rate} | {quality} | {network} |
   ...
   
   ## Top 3 Product Alternatives
   
   | # | Concept | Type | Complexity | Value |
   |---|---------|------|------------|-------|
   | 1 | {concept} | {type} | {complexity} | {value} |
   ...
   
   ## Ranking Rationale
   
   **Affiliates:**
   - #1 beats #2 because: {reason}
   ...
   
   **Products:**
   - #1 beats #2 because: {reason}
   ...
   
   ## Full Details
   
   ### Affiliate #1: {name}
   **Commission:** {rate} ({quality})
   **Topic Fit:** {fit}
   **Pitch Angle:**
   > {pitch_angle}
   
   ...
   
   ### Product #1: {concept}
   **Type:** {type}
   **Complexity:** {complexity}
   **Value:** {value}
   **Why It Beats Affiliate:** {reason}
   **Pitch Angle:**
   > {pitch_angle}
   ```

3. **generate_ranking_rationale(affiliates: list, products: list) -> dict:**
   - Use Claude to explain why #1 > #2 > #3 for each track
   - Keep rationale brief (1 sentence each)

4. **save_output(content: str, topic_slug: str, output_dir: Path = Path("output/monetization")) -> Path:**
   - Save to output/monetization/[date]-[topic_slug].md
   - Return path

Tests (test_monetization_output.py):
- Test markdown output format matches spec
- Test with 0, 1, 2, 3+ affiliates/products
- Test save/load functionality
- Test ranking rationale generation
  </action>
  <verify>pytest tests/test_monetization_output.py -v passes all tests</verify>
  <done>format_monetization_output() produces complete markdown with tables + expanded details; handles edge cases (low affiliate count)</done>
</task>

<task type="auto">
  <name>Task 3: Create CLI orchestrator and DOE crystallization</name>
  <files>execution/affiliate_finder.py, directives/affiliate_finder.md</files>
  <action>
**Create execution/affiliate_finder.py:**

1. **Main orchestrator - run_monetization_discovery(topic: str, newsletter_context: str = "", save: bool = True) -> str:**
   - Step 1: discover_affiliates(topic, newsletter_context)
   - Step 2: generate_product_alternatives(topic, newsletter_context)
   - Step 3: generate_pitches_batch(affiliates, topic, newsletter_context)
   - Step 4: format_monetization_output(affiliates, products, topic, pitches)
   - Step 5: If save=True, save_output()
   - Return formatted markdown output
   
   Handle graceful degradation:
   - If <2 affiliates found, add note recommending product path
   - If Perplexity fails, retry once then log error and continue with products only
   - If Claude fails for pitches, use placeholder text

2. **CLI interface:**
   ```
   python execution/affiliate_finder.py "email deliverability" --context "This week's newsletter covers why emails land in spam"
   
   Options:
     --context TEXT     Newsletter context for better relevance
     --no-save          Don't save output to file
     --output-dir PATH  Custom output directory
   ```

3. **DOE metadata:**
   ```python
   """
   Affiliate discovery and monetization research workflow.
   DOE-VERSION: 2026.01.31
   
   Matches directive: directives/affiliate_finder.md
   """
   ```

**Create directives/affiliate_finder.md:**

```markdown
# Affiliate Finder
<!-- DOE-VERSION: 2026.01.31 -->

## Goal
Discover monetization opportunities for weekly newsletter topics.

## Trigger Phrases
- "find affiliates for [topic]"
- "monetization options for [topic]"
- "what can I sell for [topic]"

## Quick Start
\```bash
python execution/affiliate_finder.py "[topic]" --context "[newsletter summary]"
\```

## What It Does
1. Discovers 5+ relevant affiliate programs via Perplexity
2. Generates 3 product alternatives you could create
3. Creates pitch angles for each option (Hormozi/Suby voice)
4. Outputs markdown with:
   - Top 3 affiliates (commission, quality, network)
   - Top 3 products (type, complexity, value)
   - Ranking rationale
   - Ready-to-use pitch angles

## Output
Markdown file saved to `output/monetization/[date]-[topic].md`

Contains:
- Tables for quick comparison
- Full details with pitch angles
- Decision workflow (pick affiliate OR product)

## Notes
- Affiliates verified for accessibility (not closed/waitlisted)
- Products prioritize HTML tools and automations
- If <2 good affiliates found, output recommends product path
```

**Add DOE version matching assertion** in affiliate_finder.py to verify directive version matches.
  </action>
  <verify>python execution/affiliate_finder.py --help shows usage; grep "DOE-VERSION: 2026.01.31" directives/affiliate_finder.md execution/affiliate_finder.py shows matching versions</verify>
  <done>CLI orchestrates full discovery flow; DOE directive matches script version; output saved to output/monetization/</done>
</task>

</tasks>

<verification>
1. All tests pass: `pytest tests/test_product_alternatives.py tests/test_monetization_output.py -v`
2. CLI works: `python execution/affiliate_finder.py --help`
3. DOE versions match: `grep -h "DOE-VERSION" directives/affiliate_finder.md execution/affiliate_finder.py`
4. Import chain works: `python -c "from execution.affiliate_finder import run_monetization_discovery"`
5. Output directory exists: `ls output/monetization/` (created on first run)
</verification>

<success_criteria>
1. generate_product_alternatives() returns 3 ranked product ideas with pitch angles
2. format_monetization_output() produces complete markdown matching CONTEXT.md spec
3. CLI orchestrates full flow: discovery -> generation -> formatting -> save
4. Graceful degradation when affiliates scarce (recommends products)
5. DOE directive version matches script version (2026.01.31)
6. All tests pass with mocked API responses
</success_criteria>

<output>
After completion, create `.planning/phases/05-affiliate-system/05-02-SUMMARY.md`
</output>
